<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flashcard Quiz ‚Äì H·ªçc th·∫ª v·ªõi Bootstrap</title>

  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: #f3f4f6;
      color: #111827;
      padding: 20px 0 40px;
    }

    h1 {
      font-size: 26px;
      font-weight: 700;
    }

    .badge-custom {
      font-size: 13px;
      padding: 4px 10px;
      border-radius: 999px;
    }

    .status-text {
      font-size: 13px;
      color: #6b7280;
    }

    .card-flash {
      height: 580px;
      border-radius: 18px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.12);
      overflow-y: auto;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }

    .card-flash:hover {
      transform: translateY(-2px);
      box-shadow: 0 16px 35px rgba(15, 23, 42, 0.16);
    }

    .card-question {
      font-weight: 700;
      font-size: 22px;
      line-height: 1.5;
      margin-bottom: 16px;
    }

    .card-options {
      margin: 0 0 12px 18px;
      padding: 0;
      font-size: 18px;
      list-style: none;
    }

    .card-options li {
      margin: 6px 0;
      padding: 5px 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.1s ease, border 0.1s ease;
    }

    .card-options li:hover {
      background: #f3f4f6;
    }

    /* ƒëang ch·ªçn trong test (ch∆∞a ch·∫•m) */
    .opt-selected {
      border: 1px dashed #0d6efd;
      background: #e0f2fe;
    }

    /* Test mode colors */
    .opt-correct {
      background: #dcfce7 !important;
      border: 1px solid #22c55e;
      color: #14532d;
    }

    .opt-incorrect {
      background: #fee2e2 !important;
      border: 1px solid #ef4444;
      color: #7f1d1d;
    }

    .answer-box {
      margin-top: 14px;
      padding: 10px 12px;
      border-radius: 10px;
      background: #ecfdf3;
      border: 1px solid #bbf7d0;
      font-weight: 600;
      font-size: 18px;
      display: none;

      /* kh√¥ng b·ªã c·∫Øt ch·ªØ */
      white-space: pre-wrap;
      word-break: break-word;
      overflow: visible;
    }

    #answerMessage,
    #answerText {
      display: block;
      white-space: pre-wrap;
      word-break: break-word;
      overflow: visible;
    }

    .hint-text {
      font-size: 13px;
      color: #6b7280;
    }

    .small-note {
      font-size: 12px;
      color: #6b7280;
    }

    .danger-text {
      color: #b91c1c;
      font-size: 12px;
    }

    .parse-error {
      color: #b91c1c;
      font-size: 13px;
      margin-top: 6px;
    }

    .btn-toggle-on {
      background-color: #198754;
      color: #fff;
      border-color: #198754;
    }

    .btn-test-on {
      background-color: #dc3545;
      color: #fff;
      border-color: #dc3545;
    }

    @media (max-width: 640px) {
      body {
        padding: 12px 0 32px;
      }

      .card-flash {
        height: 620px;
      }

      .card-question {
        font-size: 18px;
      }

      .card-options {
        font-size: 16px;
      }

      .answer-box {
        font-size: 16px;
      }
    }
  </style>
</head>

<body>
  <div class="container-lg">
    <h1 class="text-center mb-3">Flashcard Quiz ‚Äì H·ªçc th·∫ª</h1>

    <!-- TOP BAR -->
    <div class="d-flex justify-content-between align-items-center flex-wrap gap-2 mb-2">
      <div class="d-flex align-items-center gap-2 flex-wrap">
        <button id="openModalBtn" type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal"
          data-bs-target="#dataModal">
          üìÇ Nh·∫≠p / t·∫£i d·ªØ li·ªáu
        </button>
        <span id="cardCountBadge" class="badge badge-custom bg-secondary-subtle text-body-secondary">
          Ch∆∞a c√≥ th·∫ª n√†o
        </span>
      </div>

      <div class="d-flex flex-column align-items-end gap-1">
        <div class="d-flex align-items-center gap-2 flex-wrap">
          <button id="toggleTestBtn" type="button" class="btn btn-sm btn-outline-danger">
            üìù L√†m b√†i test: T·∫ÆT
          </button>

          <div class="form-check form-switch m-0">
            <input class="form-check-input" type="checkbox" id="shuffleCheckbox" />
            <label class="form-check-label small" for="shuffleCheckbox">
              Tr·ªôn th·∫ª khi test
            </label>
          </div>

          <button id="resetTestBtn" type="button" class="btn btn-sm btn-outline-secondary" disabled>
            ‚Ü∫ Reset test
          </button>
        </div>

        <div class="d-flex align-items-center gap-2 flex-wrap">
          <button id="toggleAutoBtn" type="button" class="btn btn-sm btn-outline-success">
            üëÅÔ∏è‚Äçüó®Ô∏è T·ª± hi·ªán ƒë√°p √°n: T·∫ÆT
          </button>
          <span class="status-text" id="statusText">
            Ch∆∞a t·∫£i d·ªØ li·ªáu. Nh·∫•n ‚ÄúNh·∫≠p / t·∫£i d·ªØ li·ªáu‚Äù ƒë·ªÉ b·∫Øt ƒë·∫ßu.
          </span>
        </div>
      </div>
    </div>

    <!-- SEARCH BAR -->
    <div class="row align-items-center g-2 mb-3">
      <div class="col-auto">
        <label for="searchInput" class="col-form-label fw-semibold">
          üîç T√¨m c√¢u h·ªèi:
        </label>
      </div>
      <div class="col">
        <input id="searchInput" type="text" class="form-control form-control-sm"
          placeholder="Nh·∫≠p t·ª´ kh√≥a trong c√¢u h·ªèi..." />
      </div>
      <div class="col-auto d-flex gap-2">
        <button id="searchBtn" type="button" class="btn btn-sm btn-outline-primary">
          T√¨m
        </button>
      </div>
      <div class="col-12 small text-muted" id="searchResult"></div>
    </div>

    <!-- CARD SECTION -->
    <div id="cardSection" class="mb-3" style="display: none">
      <div class="card card-flash mb-2" id="card">
        <div class="card-body">
          <div class="card-question" id="cardQuestion"></div>
          <ul class="card-options" id="cardOptions"></ul>
          <div class="answer-box" id="cardAnswer">
            <span id="answerMessage">
              <strong>ƒê√°p √°n:</strong>
              <span id="answerText"></span>
            </span>
          </div>
        </div>
      </div>

      <div class="text-center hint-text mb-2" id="hintText">
        üí° Click v√†o th·∫ª ho·∫∑c d√πng ‚Üë / ‚Üì / Space ƒë·ªÉ hi·ªán / ·∫©n ƒë√°p √°n.
      </div>

      <div class="d-flex align-items-center justify-content-center flex-wrap gap-2 mb-1">
        <button id="prevBtn" type="button" class="btn btn-sm btn-outline-secondary">
          ‚üµ Prev
        </button>

        <span class="small" id="indexInfo"></span>

        <button id="nextBtn" type="button" class="btn btn-sm btn-outline-secondary">
          Next ‚ü∂
        </button>

        <div class="d-flex align-items-center gap-1">
          <input type="number" min="1" id="jumpInput" class="form-control form-control-sm" style="width: 90px"
            placeholder="Th·∫ª #" />
          <button id="jumpBtn" type="button" class="btn btn-sm btn-outline-secondary">
            ƒê·∫øn
          </button>
        </div>
      </div>

      <div class="text-center small text-success" id="perCardStatus"></div>
    </div>

    <!-- EMPTY STATE -->
    <div id="emptyState" class="text-center text-muted mt-4">
      Ch∆∞a c√≥ d·ªØ li·ªáu n√†o. H√£y nh·∫•n
      <strong>‚ÄúNh·∫≠p / t·∫£i d·ªØ li·ªáu‚Äù</strong> ƒë·ªÉ th√™m b·ªô c√¢u h·ªèi.
    </div>
  </div>

  <!-- MODAL: INPUT / UPLOAD DATA -->
  <div class="modal fade" id="dataModal" tabindex="-1" aria-labelledby="dataModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="dataModalLabel">
            Nh·∫≠p / t·∫£i d·ªØ li·ªáu c√¢u h·ªèi
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="ƒê√≥ng"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <h6>1Ô∏è‚É£ Nh·∫≠p d·ªØ li·ªáu th·ªß c√¥ng</h6>
            <p class="small-note mb-2">
              D√°n n·ªôi dung t·ª´ Word/TXT, format: c√¢u h·ªèi + c√°c d√≤ng
              <code>a.</code>, <code>b.</code>... v√† d√≤ng cu·ªëi c√πng l√†
              <strong>m·ªôt ho·∫∑c nhi·ªÅu ch·ªØ c√°i A/B/C/D (vd: A, AC)</strong>.
            </p>
            <textarea id="rawInput" class="form-control mb-2" rows="6" placeholder="//C√¢u h·ªèi...

a. ƒê√°p √°n 1
b. ƒê√°p √°n 2
c. ƒê√°p √°n 3
d. ƒê√°p √°n 4

ac   (A v√† C c√πng ƒë√∫ng)"></textarea>
            <button id="parseBtn" type="button" class="btn btn-primary btn-sm">
              T·∫°o th·∫ª t·ª´ n·ªôi dung
            </button>
          </div>

          <hr />

          <div class="mb-3">
            <h6>2Ô∏è‚É£ Ho·∫∑c upload file (.json ho·∫∑c .txt)</h6>
            <p class="small-note mb-2">
              JSON m·ªõi n√™n d√πng d·∫°ng:
              <code>
                [{"{"}"question":"...","options":[{"{"}"label":"A","text":"..."}],
                "answers":["A","D"]{"}"}]
              </code>
              <br />
              V·∫´n h·ªó tr·ª£ d·∫°ng c≈©:
              <code> "answer":"B" </code>
              v√† c·∫£ d·∫°ng:
              <code>"correctAnswers":["A","D"]</code>
            </p>
            <div class="d-flex align-items-center gap-2 flex-wrap">
              <input type="file" id="fileInput" class="form-control form-control-sm" accept=".json,.txt" />
              <button id="uploadBtn" type="button" class="btn btn-outline-secondary btn-sm">
                T·∫£i file l√™n
              </button>
            </div>
          </div>

          <div class="mb-2">
            <button id="clearStorageBtn" type="button" class="btn btn-outline-danger btn-sm">
              üóë Xo√° d·ªØ li·ªáu ƒë√£ l∆∞u
            </button>
            <span class="danger-text ms-1">
              S·∫Ω xo√° b·ªô th·∫ª v√† ti·∫øn ƒë·ªô ƒëang l∆∞u trong tr√¨nh duy·ªát.
            </span>
          </div>

          <div id="parseError" class="parse-error"></div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">
            ƒê√≥ng
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- MODAL: SEARCH RESULTS -->
  <div class="modal fade" id="searchModal" tabindex="-1" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="searchModalLabel">K·∫øt qu·∫£ t√¨m ki·∫øm</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="ƒê√≥ng"></button>
        </div>
        <div class="modal-body">
          <div id="searchList" class="list-group small"></div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">ƒê√≥ng</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS bundle -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // ---- DOM ELEMENTS ----
      const cardSection = document.getElementById("cardSection");
      const emptyState = document.getElementById("emptyState");

      const card = document.getElementById("card");
      const cardQuestion = document.getElementById("cardQuestion");
      const cardOptions = document.getElementById("cardOptions");
      const cardAnswer = document.getElementById("cardAnswer");
      const answerText = document.getElementById("answerText");
      const answerMessage = document.getElementById("answerMessage");
      const hintText = document.getElementById("hintText");

      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const indexInfo = document.getElementById("indexInfo");
      const perCardStatus = document.getElementById("perCardStatus");
      const jumpInput = document.getElementById("jumpInput");
      const jumpBtn = document.getElementById("jumpBtn");

      const cardCountBadge = document.getElementById("cardCountBadge");
      const statusText = document.getElementById("statusText");
      const toggleAutoBtn = document.getElementById("toggleAutoBtn");
      const toggleTestBtn = document.getElementById("toggleTestBtn");
      const shuffleCheckbox = document.getElementById("shuffleCheckbox");
      const resetTestBtn = document.getElementById("resetTestBtn");

      const rawInput = document.getElementById("rawInput");
      const parseBtn = document.getElementById("parseBtn");
      const fileInput = document.getElementById("fileInput");
      const uploadBtn = document.getElementById("uploadBtn");
      const clearStorageBtn = document.getElementById("clearStorageBtn");
      const parseError = document.getElementById("parseError");

      const searchInput = document.getElementById("searchInput");
      const searchBtn = document.getElementById("searchBtn");
      const searchResult = document.getElementById("searchResult");

      const dataModalEl = document.getElementById("dataModal");
      const dataModal = new bootstrap.Modal(dataModalEl);

      const searchModalEl = document.getElementById("searchModal");
      const searchList = document.getElementById("searchList");
      const searchModal = new bootstrap.Modal(searchModalEl);

      // ---- STATE ----
      let cards = [];
      let currentPos = 0; // v·ªã tr√≠ logic hi·ªán t·∫°i (0..n-1)
      let autoShowAnswers = false;
      let testMode = false;
      let useShuffle = false;

      let testOrder = []; // m·∫£ng index card khi test
      let perCardEverCorrect = []; // ƒë√°nh d·∫•u c√¢u n√†o t·ª´ng ƒë√∫ng

      let totalAnswered = 0;
      let totalCorrect = 0;
      let hasAnsweredCurrent = false;
      let currentSelectedLabels = new Set(); // l·ª±a ch·ªçn hi·ªán t·∫°i trong test mode

      const STORAGE_KEY_DATA = "flashcards_data";
      const STORAGE_KEY_INDEX = "flashcards_index";
      const STORAGE_KEY_AUTO = "flashcards_auto_show";

      // ---- HELPERS ----
      function normalizeCards(arr) {
        if (!Array.isArray(arr)) return [];
        for (const c of arr) {
          if (!c || typeof c !== "object") continue;
          let answers = [];

          // ∆Øu ti√™n correctAnswers (ƒë·ªãnh d·∫°ng c·ªßa file json m·ªõi)
          if (Array.isArray(c.correctAnswers) && c.correctAnswers.length) {
            answers = c.correctAnswers
              .map((x) => String(x).toUpperCase())
              .filter((ch) => /^[A-D]$/.test(ch));
          } else if (Array.isArray(c.answers) && c.answers.length) {
            answers = c.answers
              .map((x) => String(x).toUpperCase())
              .filter((ch) => /^[A-D]$/.test(ch));
          } else if (typeof c.answer === "string") {
            const ms = c.answer.toUpperCase().match(/[A-D]/g);
            if (ms) answers = Array.from(new Set(ms));
          }

          if (!answers.length) {
            if (Array.isArray(c.options) && c.options.length > 0) {
              const first = c.options[0];
              if (first && first.label) {
                answers = [String(first.label).toUpperCase()];
              }
            }
          }

          c.answers = answers;
          c.correctAnswers = answers;
          c.answer = answers[0] || c.answer || null;
        }
        return arr;
      }

      function getAnswers(card) {
        if (!card) return [];
        if (Array.isArray(card.answers) && card.answers.length) {
          return card.answers;
        }
        if (Array.isArray(card.correctAnswers) && card.correctAnswers.length) {
          return card.correctAnswers;
        }
        if (typeof card.answer === "string") {
          const ms = card.answer.toUpperCase().match(/[A-D]/g);
          if (ms) return Array.from(new Set(ms));
        }
        return [];
      }

      function buildAnswerText(card) {
        const answers = getAnswers(card);
        if (!answers.length) return "";
        const opts = Array.isArray(card.options) ? card.options : [];
        const parts = [];
        for (const lbl of answers) {
          const opt = opts.find((o) => o.label === lbl);
          if (opt) {
            parts.push(`${opt.label}. ${opt.text}`);
          } else {
            parts.push(lbl);
          }
        }
        return parts.join("; ");
      }

      function parseFromText(text) {
        const blocks = text.trim().split(/\n\s*\n+/);
        const result = [];

        for (const block of blocks) {
          const lines = block
            .split("\n")
            .map((l) => l.trim())
            .filter(Boolean);
          if (lines.length < 3) continue;

          const ansLine = lines[lines.length - 1].trim();
          const letters = ansLine.toUpperCase().match(/[A-D]/g) || [];
          const uniqueLetters = Array.from(new Set(letters));
          if (!uniqueLetters.length) continue;

          let optStart = null;
          for (let i = 0; i < lines.length; i++) {
            if (/^[A-Da-d][\.\)]\s+/.test(lines[i])) {
              optStart = i;
              break;
            }
          }
          if (optStart === null) continue;

          const questionLines = lines.slice(0, optStart);
          const question = questionLines.join(" ").replace(/^\/\//, "").trim();

          const optionLines = lines.slice(optStart, lines.length - 1);
          const options = [];
          for (const line of optionLines) {
            const m = line.match(/^([A-Da-d])[\.\)]\s*(.+)$/);
            if (!m) continue;
            options.push({ label: m[1].toUpperCase(), text: m[2].trim() });
          }
          if (!options.length) continue;

          result.push({
            question,
            options,
            answers: uniqueLetters,
          });
        }
        return normalizeCards(result);
      }

      function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      function getCurrentCardIndex() {
        if (!cards.length) return 0;
        if (testMode) {
          if (!testOrder.length) {
            testOrder = Array.from({ length: cards.length }, (_, i) => i);
          }
          return testOrder[currentPos] ?? 0;
        }
        return currentPos;
      }

      function saveIndexToStorage() {
        try {
          const idx = getCurrentCardIndex();
          localStorage.setItem(STORAGE_KEY_INDEX, String(idx));
        } catch (e) { }
      }

      function saveDataToStorage() {
        try {
          if (cards && cards.length > 0) {
            localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(cards));
          }
        } catch (e) { }
      }

      function saveAutoToStorage() {
        try {
          localStorage.setItem(
            STORAGE_KEY_AUTO,
            autoShowAnswers ? "1" : "0"
          );
        } catch (e) { }
      }

      function clearStorage() {
        try {
          localStorage.removeItem(STORAGE_KEY_DATA);
          localStorage.removeItem(STORAGE_KEY_INDEX);
        } catch (e) { }
      }

      function loadStateFromStorage() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY_DATA);
          if (raw) {
            const storedCards = normalizeCards(JSON.parse(raw));
            if (Array.isArray(storedCards) && storedCards.length) {
              cards = storedCards;
              perCardEverCorrect = new Array(cards.length).fill(false);
            }
          }

          const idxRaw = localStorage.getItem(STORAGE_KEY_INDEX);
          if (idxRaw !== null) {
            let idx = parseInt(idxRaw, 10);
            if (!Number.isNaN(idx)) currentPos = idx;
          }

          const autoRaw = localStorage.getItem(STORAGE_KEY_AUTO);
          if (autoRaw === "1") autoShowAnswers = true;

          if (cards.length) {
            if (currentPos < 0) currentPos = 0;
            if (currentPos >= cards.length) currentPos = cards.length - 1;
            cardSection.style.display = "block";
            emptyState.style.display = "none";
            renderCard();
          }
        } catch (e) { }
      }

      function updateBadges() {
        if (cards.length > 0) {
          let extra = "";
          if (testMode) {
            extra = ` | Test: ƒë√∫ng ${totalCorrect}/${totalAnswered}`;
          } else if (autoShowAnswers) {
            extra = " | ƒêang ·ªü ch·∫ø ƒë·ªô t·ª± hi·ªán ƒë√°p √°n";
          }
          cardCountBadge.textContent = `${cards.length} th·∫ª`;
          statusText.textContent = `Th·∫ª hi·ªán t·∫°i: ${getCurrentCardIndex() + 1
            }/${cards.length}.${extra}`;
        } else {
          cardCountBadge.textContent = "Ch∆∞a c√≥ th·∫ª n√†o";
          statusText.textContent =
            "Ch∆∞a t·∫£i d·ªØ li·ªáu. Nh·∫•n ‚ÄúNh·∫≠p / t·∫£i d·ªØ li·ªáu‚Äù ƒë·ªÉ b·∫Øt ƒë·∫ßu.";
        }
      }

      function updateAutoButtonAndHint() {
        if (autoShowAnswers) {
          toggleAutoBtn.textContent = "üëÅÔ∏è‚Äçüó®Ô∏è T·ª± hi·ªán ƒë√°p √°n: B·∫¨T";
          toggleAutoBtn.classList.add("btn-toggle-on");
        } else {
          toggleAutoBtn.textContent = "üëÅÔ∏è‚Äçüó®Ô∏è T·ª± hi·ªán ƒë√°p √°n: T·∫ÆT";
          toggleAutoBtn.classList.remove("btn-toggle-on");
        }

        if (testMode) {
          hintText.textContent =
            "üìù Ch·∫ø ƒë·ªô l√†m b√†i test: ch·ªçn ƒë·ªß ƒë√°p √°n ƒë√∫ng r·ªìi h·ªá th·ªëng s·∫Ω ch·∫•m. (Kh√¥ng d√πng ‚Üë/‚Üì/Space ƒë·ªÉ show ƒë√°p √°n)";
        } else if (autoShowAnswers) {
          hintText.textContent =
            "üìñ ƒêang ·ªü ch·∫ø ƒë·ªô h·ªçc l∆∞·ªõt: ƒë√°p √°n t·ª± ƒë·ªông hi·ªÉn th·ªã. Ch·ªâ d√πng ‚Üê / ‚Üí ƒë·ªÉ chuy·ªÉn th·∫ª.";
        } else {
          hintText.textContent =
            "üí° Click v√†o th·∫ª ho·∫∑c d√πng ‚Üë / ‚Üì / Space ƒë·ªÉ hi·ªán / ·∫©n ƒë√°p √°n. D√πng ‚Üê / ‚Üí ƒë·ªÉ chuy·ªÉn th·∫ª.";
        }

        updateBadges();
      }

      function updateTestButton() {
        if (testMode) {
          toggleTestBtn.textContent = "üìù L√†m b√†i test: B·∫¨T";
          toggleTestBtn.classList.add("btn-test-on");
          resetTestBtn.disabled = false;
        } else {
          toggleTestBtn.textContent = "üìù L√†m b√†i test: T·∫ÆT";
          toggleTestBtn.classList.remove("btn-test-on");
          resetTestBtn.disabled = true;
        }
        updateAutoButtonAndHint();
      }

      function setupTestSession() {
        if (!cards.length) return;
        useShuffle = shuffleCheckbox.checked;
        testOrder = Array.from({ length: cards.length }, (_, i) => i);
        if (useShuffle) shuffleArray(testOrder);
        perCardEverCorrect = new Array(cards.length).fill(false);
        totalAnswered = 0;
        totalCorrect = 0;
        currentPos = 0;
        hasAnsweredCurrent = false;
        currentSelectedLabels = new Set();
      }

      function renderCard() {
        if (!cards.length) {
          cardSection.style.display = "none";
          emptyState.style.display = "block";
          updateBadges();
          return;
        }

        const cardIndex = getCurrentCardIndex();
        const c = cards[cardIndex];
        hasAnsweredCurrent = false;
        currentSelectedLabels = new Set();

        cardQuestion.textContent = c.question || "Kh√¥ng c√≥ c√¢u h·ªèi";

        cardOptions.innerHTML = "";
        if (Array.isArray(c.options)) {
          c.options.forEach((o) => {
            const li = document.createElement("li");
            li.textContent = `${o.label}. ${o.text}`;
            li.dataset.label = o.label;
            li.classList.remove("opt-correct", "opt-incorrect", "opt-selected");
            cardOptions.appendChild(li);
          });
        }

        const ansText = buildAnswerText(c);
        answerText.textContent = ansText || "";

        if (testMode) {
          cardAnswer.style.display = "none";
        } else {
          cardAnswer.style.display = autoShowAnswers ? "block" : "none";
          answerMessage.innerHTML =
            "<strong>ƒê√°p √°n ƒë√∫ng:</strong> " + (ansText || "");
        }

        indexInfo.textContent = `Th·∫ª ${cardIndex + 1
          } / ${cards.length}`;

        prevBtn.disabled = currentPos === 0;
        nextBtn.disabled = currentPos === cards.length - 1;

        if (testMode && perCardEverCorrect[cardIndex]) {
          perCardStatus.textContent = "‚úÖ C√¢u n√†y ƒë√£ t·ª´ng l√†m ƒë√∫ng.";
        } else {
          perCardStatus.textContent = "";
        }

        cardSection.style.display = "block";
        emptyState.style.display = "none";
        updateBadges();
        saveIndexToStorage();
      }

      function goPrevCard() {
        if (!cards.length) return;
        if (currentPos > 0) {
          currentPos--;
          renderCard();
        }
      }

      function goNextCard() {
        if (!cards.length) return;
        if (currentPos < cards.length - 1) {
          currentPos++;
          renderCard();
        }
      }

      function toggleAnswerVisibility() {
        if (testMode || autoShowAnswers) return;
        if (
          cardAnswer.style.display === "none" ||
          cardAnswer.style.display === ""
        ) {
          cardAnswer.style.display = "block";
        } else {
          cardAnswer.style.display = "none";
        }
      }

      function goToCard(idx) {
        if (!cards.length) return;
        if (idx < 0 || idx >= cards.length) return;
        testMode = false;      // chuy·ªÉn v·ªÅ ch·∫ø ƒë·ªô h·ªçc ƒë·ªÉ xem n·ªôi dung
        updateTestButton();
        currentPos = idx;
        renderCard();
      }

      // ---- EVENTS: CARDS / TEST / AUTO ----
      prevBtn.addEventListener("click", goPrevCard);
      nextBtn.addEventListener("click", goNextCard);

      card.addEventListener("click", function (e) {
        if (e.target && e.target.closest("li")) return;
        if (testMode || autoShowAnswers) return;
        toggleAnswerVisibility();
      });

      // TEST MODE: multi-select, ch·ªâ ch·∫•m khi ƒë√£ ch·ªçn ƒë·ªß s·ªë ƒë√°p √°n ƒë√∫ng
      cardOptions.addEventListener("click", function (e) {
        const li = e.target.closest("li");
        if (!li) return;
        if (!testMode) return;
        if (hasAnsweredCurrent) return;

        const cardIndex = getCurrentCardIndex();
        const c = cards[cardIndex];
        const label = li.dataset.label;
        const correctLabels = getAnswers(c);
        const requiredCount = correctLabels.length || 1;

        // toggle ch·ªçn / b·ªè ch·ªçn
        if (currentSelectedLabels.has(label)) {
          currentSelectedLabels.delete(label);
          li.classList.remove("opt-selected");
        } else {
          currentSelectedLabels.add(label);
          li.classList.add("opt-selected");
        }

        // ch∆∞a ƒë·ªß s·ªë l∆∞·ª£ng -> ch∆∞a ch·∫•m
        if (currentSelectedLabels.size < requiredCount) {
          return;
        }

        // b·∫Øt ƒë·∫ßu ch·∫•m
        hasAnsweredCurrent = true;
        totalAnswered += 1;

        const selectedArr = Array.from(currentSelectedLabels).sort();
        const correctSorted = [...correctLabels].sort();
        let isCorrect =
          selectedArr.length === correctSorted.length &&
          selectedArr.every((lbl, idx) => lbl === correctSorted[idx]);

        // Clear class c≈©
        [...cardOptions.querySelectorAll("li")].forEach((item) => {
          item.classList.remove("opt-correct", "opt-incorrect", "opt-selected");
        });

        // ƒë√°nh d·∫•u ƒë√°p √°n ƒë√∫ng
        [...cardOptions.querySelectorAll("li")].forEach((item) => {
          const lbl = item.dataset.label;
          if (correctLabels.includes(lbl)) {
            item.classList.add("opt-correct");
          }
        });

        // ƒë√°nh d·∫•u l·ª±a ch·ªçn sai
        if (!isCorrect) {
          [...cardOptions.querySelectorAll("li")].forEach((item) => {
            const lbl = item.dataset.label;
            if (
              currentSelectedLabels.has(lbl) &&
              !correctLabels.includes(lbl)
            ) {
              item.classList.add("opt-incorrect");
            }
          });
        }

        const ansText = buildAnswerText(c);

        if (isCorrect) {
          answerMessage.innerHTML = "‚úÖ ƒê√∫ng! ƒê√°p √°n: " + (ansText || "");
          perCardEverCorrect[cardIndex] = true;
          totalCorrect += 1;
        } else {
          answerMessage.innerHTML =
            "‚ùå Sai. ƒê√°p √°n ƒë√∫ng l√†: " + (ansText || "");
        }

        cardAnswer.style.display = "block";
        updateBadges();

        if (perCardEverCorrect[cardIndex]) {
          perCardStatus.textContent = "‚úÖ C√¢u n√†y ƒë√£ t·ª´ng l√†m ƒë√∫ng.";
        } else {
          perCardStatus.textContent = "";
        }
      });

      toggleAutoBtn.addEventListener("click", function () {
        autoShowAnswers = !autoShowAnswers;
        saveAutoToStorage();
        updateAutoButtonAndHint();
        if (!testMode) renderCard();
      });

      toggleTestBtn.addEventListener("click", function () {
        if (!cards.length) return;

        if (!testMode) {
          testMode = true;
          setupTestSession();
        } else {
          const cardIndex = getCurrentCardIndex();
          testMode = false;
          currentPos = cardIndex;
        }
        updateTestButton();
        renderCard();
      });

      resetTestBtn.addEventListener("click", function () {
        if (!testMode || !cards.length) return;
        setupTestSession();
        renderCard();
      });

      // ---- JUMP TO CARD ----
      jumpBtn.addEventListener("click", function () {
        if (!cards.length) return;
        const value = parseInt(jumpInput.value, 10);
        if (Number.isNaN(value)) return;
        let n = value;
        if (n < 1) n = 1;
        if (n > cards.length) n = cards.length;
        currentPos = n - 1;
        renderCard();
      });

      jumpInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter") {
          e.preventDefault();
          jumpBtn.click();
        }
      });

      // ---- SEARCH BY QUESTION (v·ªõi popup danh s√°ch) ----
      function searchQuestion() {
        const q = (searchInput.value || "").trim().toLowerCase();
        searchResult.textContent = "";
        if (!q) return;

        if (!cards.length) {
          searchResult.textContent = "Ch∆∞a c√≥ th·∫ª n√†o ƒë·ªÉ t√¨m.";
          return;
        }

        const matches = [];
        cards.forEach((c, idx) => {
          const text = (c.question || "").toLowerCase();
          if (text.includes(q)) {
            matches.push({ index: idx, question: c.question || "" });
          }
        });

        if (!matches.length) {
          searchResult.textContent = "Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi n√†o ph√π h·ª£p.";
          return;
        }

        if (matches.length === 1) {
          const idx = matches[0].index;
          goToCard(idx);
          searchResult.textContent = `T√¨m th·∫•y 1 c√¢u, ƒëang ƒë·∫øn th·∫ª #${idx + 1}.`;
          return;
        }

        // nhi·ªÅu k·∫øt qu·∫£ -> show modal
        searchList.innerHTML = "";
        matches.forEach((m) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "list-group-item list-group-item-action";
          btn.dataset.index = m.index;
          const shortText =
            m.question.length > 200
              ? m.question.slice(0, 200) + "..."
              : m.question;
          btn.textContent = `#${m.index + 1} ‚Äì ${shortText}`;
          searchList.appendChild(btn);
        });

        searchResult.textContent = `T√¨m th·∫•y ${matches.length} c√¢u. Ch·ªçn m·ªôt c√¢u trong danh s√°ch.`;
        searchModal.show();
      }

      searchBtn.addEventListener("click", searchQuestion);
      searchInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter") {
          e.preventDefault();
          searchQuestion();
        }
      });

      // click item trong popup ƒë·ªÉ nh·∫£y t·ªõi th·∫ª ƒë√≥
      searchList.addEventListener("click", function (e) {
        const item = e.target.closest(".list-group-item");
        if (!item) return;
        const idx = parseInt(item.dataset.index, 10);
        if (Number.isNaN(idx)) return;
        goToCard(idx);
        searchModal.hide();
      });

      // ---- DATA MODAL: PARSE / UPLOAD / CLEAR ----
      parseBtn.addEventListener("click", function () {
        const text = rawInput.value || "";
        parseError.textContent = "";
        const parsed = parseFromText(text);
        if (!parsed.length) {
          parseError.textContent =
            "‚ùå Kh√¥ng parse ƒë∆∞·ª£c th·∫ª n√†o. Ki·ªÉm tra l·∫°i format.";
          return;
        }
        cards = parsed;
        currentPos = 0;
        perCardEverCorrect = new Array(cards.length).fill(false);
        totalAnswered = 0;
        totalCorrect = 0;
        testMode = false;
        updateTestButton();

        cardSection.style.display = "block";
        emptyState.style.display = "none";
        saveDataToStorage();
        renderCard();
        dataModal.hide();
      });

      uploadBtn.addEventListener("click", function () {
        const file = fileInput.files && fileInput.files[0];
        parseError.textContent = "";
        if (!file) {
          parseError.textContent = "‚ùå B·∫°n ch∆∞a ch·ªçn file.";
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const content = e.target.result;
            let parsed;
            if (file.name.toLowerCase().endsWith(".json")) {
              parsed = normalizeCards(JSON.parse(content));
              if (!Array.isArray(parsed)) {
                throw new Error("JSON ph·∫£i l√† m·ªôt m·∫£ng.");
              }
            } else {
              parsed = parseFromText(content);
            }

            if (!parsed.length) {
              throw new Error("Kh√¥ng c√≥ th·∫ª h·ª£p l·ªá trong file.");
            }

            cards = parsed;
            currentPos = 0;
            perCardEverCorrect = new Array(cards.length).fill(false);
            totalAnswered = 0;
            totalCorrect = 0;
            testMode = false;
            updateTestButton();

            saveDataToStorage();
            renderCard();
            dataModal.hide();
          } catch (err) {
            console.error(err);
            parseError.textContent =
              "‚ùå L·ªói ƒë·ªçc file. Ki·ªÉm tra l·∫°i format JSON ho·∫∑c TXT.";
          }
        };
        reader.readAsText(file, "utf-8");
      });

      clearStorageBtn.addEventListener("click", function () {
        if (
          !confirm(
            "B·∫°n c√≥ ch·∫Øc mu·ªën xo√° b·ªô th·∫ª v√† ti·∫øn ƒë·ªô ƒë√£ l∆∞u kh√¥ng?"
          )
        )
          return;
        clearStorage();
        cards = [];
        currentPos = 0;
        perCardEverCorrect = [];
        totalAnswered = 0;
        totalCorrect = 0;
        testMode = false;
        updateTestButton();
        cardSection.style.display = "none";
        emptyState.style.display = "block";
        updateBadges();
        parseError.textContent = "ƒê√£ xo√° d·ªØ li·ªáu trong tr√¨nh duy·ªát.";
      });

      // ---- KEYBOARD SHORTCUTS ----
      document.addEventListener("keydown", function (e) {
        if (document.querySelector(".modal.show")) return;

        const tag = (e.target.tagName || "").toUpperCase();
        if (tag === "INPUT" || tag === "TEXTAREA") return;

        if (e.key === "ArrowLeft") {
          e.preventDefault();
          goPrevCard();
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          goNextCard();
        } else if (
          e.key === "ArrowUp" ||
          e.key === "ArrowDown" ||
          e.key === " "
        ) {
          if (autoShowAnswers || testMode) return;
          e.preventDefault();
          toggleAnswerVisibility();
        }
      });

      // ---- INIT ----
      loadStateFromStorage();
      updateTestButton();
      updateAutoButtonAndHint();
      updateBadges(); 
    });
  </script>
</body>

</html>
